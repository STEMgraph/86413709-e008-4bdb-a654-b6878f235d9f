\learningobjective{At the end of this challenge, the scholar will be able to use the echo, ls and cat commands. And perform simple redirections.}
\begin{challenge}
    \chatitle{Input and Output to and from the command line interpreter} 
 
    \begin{chadescription}
        When we are talking about computers, what we mean is a piece of electronic hardware, that is able to perform algorithmic and logic mappings from a binary number to another binary number.
        Interfacing with this hardware can be tricky, thats why modern computers come with an operating system.
        This operating system provides us with a helper program, called the Shell.
        The Shell is a program, that \textit{wraps} around the operating-systems inner core, also known as the kernel.
        Sending commands to the kernel can be really tedious and error-prone, thats why the Shell gives us a more user-friendly interface.
        The Shell itself is the program that interpretes our input from RAM, prepares the data for the kernel sends a request to have it evaluated and stores the hardwares answer back in RAM.
        Before there were interactive keyboard terminals to computers, the content of the RAM was set manually, by connecting switches and wires to high or low voltages.
        In the 1950, the \textbf{MIT Whirlwind} computer was the first computer to use an electronic typewriter, to interact with the user in real-time - that means in cycles of \textit{read-compute-write} while the computer was running.
        An electric typewriter is a magnificent machine. 
        In contrast to mechnical typewriters that have a mechnical connection between each key and a specific hammer, keys in electrical typewriters activate a set of switches to electrically choose which character shall be printed to the paper and sort of a motor to hammer.
        The idea of the interactive terminal was it, to interrupt the signal from the key to the typing-electronics and rerouting it to a computer, that performs a transformation of the electrical signal, and sends the modified signal to the typing-electronics. 
        A button that was pressed on the keyboard was translated into a signal that was sent to the computers memory using a serializer-deserializer-circuit.
        The computer would perform a transformation of that piece of memory and generate a new sequence of electrical signals.
        An output that was written by the shell-program to memory was translated back into a signal that was sent to the terminals electrical typing-system.
        The structure of todays machines is still somewhat comperable, but instead of an electric-typewriter-terminal, we now have computers with a so-called terminal-emulator. 
        You should always keep in mind, that the calculation mechanism of the computer and the input and output are seperate systems!\\
        In 1988 a group of electrical engineers, mathematicians and physicists came up with the idea of writing down a standardized way how input, output and operating-systems should interact with one another, making it easier for programmers, to build programs for different types of computers. 
        You have to imagine, that before that this standardization, every computer was basically completely different. 
        The standard is still widely used in an updated version and is called Portable Operating System Interface or short: \textbf{POSIX}.
        POSIX also defines what a \textit{FILE} is supposed to be and how it should be used. 
        You probably know some FILEs from your home-computer already but you may have not heard of the kind of FILEs that we will be talking about in this challenge.\\
        Operating-systems come with a piece of software called a \textit{filesystem}.
        It is the responsibility of the filesystem, to give every piece of memory on the computer, that is available to the programmer a human-readable name.
        Please keep in mind, that our computer is just wires, capacitors, transistors and such.
        There are no real names for our harddisk, our RAM or anything else. 
        Thus the filesystem is configured in a way, that we can address these memory-regions by an alias or identifier. 
        These identifiers are called filenames. 
        Let's explore some basic commands of the command-line-interpreter, that we can use to interact with the filesystem!
    \end{chadescription}

    \begin{task}
        Start up your terminal-emulator, type \texttt{echo "Hallo"} and press \texttt{Enter}.
        The Terminal will respond with \texttt{Hallo}.
        \texttt{echo} is a subroutine, that is build into the command-line-interpreter.
        Everytime a program or programmer calls the \texttt{echo}-routine, the command-line-interpreter will write the argument to the standard output.\\
        Now call \texttt{ls} and press \texttt{Enter}.
        \texttt{ls} is a program that is installed on your computer.
        It generates a list of files, that are available to you at the moment and echos it to the standard output.
        If you have not used the terminal that much before, you might see only a few or no files at all. 
        If you have used your computer and especially the terminal a lot, you might see more files there. 
        Let's start by writing some text to our filesystem by typing:
        \begin{lstlisting}
            echo "My First Text" > new_file.txt 
        \end{lstlisting}
        Press \texttt{Enter} to confirm.
        Let's use \texttt{ls} again and see what we get.

        \begin{quesitons}
            \item What does the command \texttt{echo} do?
            \item What does the command \texttt{ls} do?
            \item What do you observe as output, when using \texttt{echo} with a postfix \texttt{>}?
            \item How did the output of \texttt{ls} change after using \texttt{echo} with a postfix \texttt{>}?
        \end{quesitons}
    \end{task}

    \begin{task}
        As you have probably guessed correctly, the command we used generated a new file on our computer.
        THe command has two seperate parts, the \texttt{echo} and the \textit{redirection}.
        We discussed the echo already, and found out that it echos the argument to the standard output.
        The \texttt{>} is called the \textit{redirection operator}.
        It tells the command-line-interpreter, that the result of the evaluation of the expression to the left should not be written to the standard output, but to a different memory-location, usually indicated by a filename: in this case \texttt{new_file.txt}.
        Let's inspect the new file now.
        Type \texttt{cat new_file.txt} and press \texttt{Enter}.
        \texttt{cat} is another program installed on your computer.
        It reads the content of the argument and echos it to the standard output.
        You should see a pattern here already: many of the tools we use from the command-line, are executed by calling their name and passing an argument.
        Some programs also accept multiple arguments.\\
        Create a second file now, called \texttt{new_file2.txt} and write some text into it, using \texttt{ls >}.
        Then use \texttt{cat} to inspect the content of the new file.
        \texttt{cat} can also be called with two arguments. 
        Call \texttt{cat new_file.txt new_file2.txt} and inspect the output.
        You see your Output on the standard terminal output again, redirect the output to a new file, called \texttt{new_file3.txt} and inspect the content of the new file.
        Now, call \texttt{echo "Hello World" > new_file3.txt} and inspect the content of the new file again.
        In a second attempt call \texttt{echo "A next line" >> new_file3.txt} and inspect the content of the new file again.
        And for the final trick, try the following command:
        \begin{lstlisting}
            (cat file1.txt file2.txt file3.txt; echo "Another Line") > file4.txt
        \end{lstlisting}
        \begin{questions}
            \item What does the command \texttt{cat} do if you pass one parameter?
            \item What does the command \texttt{cat} do if you pass multiple parameters?
            \item What is the difference between the \texttt{>} and the \texttt{>>} operators?
            \item What happens when you put parentheses around two commands, separated by a semicolon?
        \end{questions}
    \end{task}


    \begin{advice}
        Let someone from your peer-group try out your challenges!
        Have them generate issues in the github repository and let them write down how long it took them to complete the challenge.
        A good challenge is one, that takes less than 30 minutes to complete.
        This way, scholars can plan their day.
        Happy generating!
    \end{advice}
\end{challenge}
